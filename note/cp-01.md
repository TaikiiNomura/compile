# コンパイラの役割
## 人間がプログラムを見ると一見して何をしているかわかる
```c
#include<stdio.h>
int main()
{
    printf("Hello world");
    return 0;
}
```
## コンピュータは1文字１文字読み取りながら全体を把握しないといけない
- どのような関数が定義されていて，本体ではどのような関係で記述されている？
```md
#→i→n→c→l→u→d→e→<→s→t→d→i→o→.→h→>→i→n→t→ →m→a→i→n→(→)→ →{→\n→	 
→p→r→i→n→t→f→(→“→H→e→ l→l→o→ →W→o→r→l→d→\n→” →)→;→r→e→t→u→r→n→ →0→;→}
```
## 木構造
- 関数定義を頂点とする木構造
```txt
                    関数定義
            ____________|____________
            |           |           |
        型指定　　関数の頭書き　　関数本体
        int　　　main ( )　　　　{ print
```
- **コンパイラの役割は，プログラムを１文字ずつ読んで構造を把握しそれと等価な仕事をする別のプログラムを生成すること**

## コンパイルプロセス
1. 字句解析
    - ソースを１文字ずつ読み，意味のある最小単位の字句を認識
2. 構文解析
    - 字句列を受け取り，字句列を生み出した文法規則を見つける
3. 中間コード生成
    - 構文解析木をもとに同等の計算をするプログラムを中間コード（疑似コード）で生成
4. コード最適化
    - 中間コードの最適化
5. オブジェクトコード生成
    - 中間コードで書かれたプログラムをコンピュータの機種に応じたネイティブコードに変換

## 文法の記述
- 通常BNF(Backus Naur form：バッカスナウア記法)で記述される
- ALGOL言語の文法定義方法
- 構文変数（非終端記号）がどのような記号に書き換えることが定義したもの

### while文の定義
- <while文> -> while(<式>)<文>
### if & for文の定義
- <if文> -> if (<式>)<分> [else <文>]
- <for文> -> for([<式>]; [<式>]; [<式>])<分>

## 導出と還元
### 導出
- 構文変数ど終端記号の入り混じった記号列からいずれかの構文変数をその定義式の右辺で書き換える

### 還元
- 終端記号だけの記号列の中から，一部を取り出し対応する規則の左辺の構文変数に書き換える